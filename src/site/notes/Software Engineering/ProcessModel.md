---
{"dg-publish":true,"permalink":"/Software Engineering/ProcessModel/"}
---



**소프트웨어 프로세스 및 그 모델**

---

**다루는 주제**

- **소프트웨어 프로세스 모델**
  - 폭포수 모델 (Waterfall)
  - 진화적 모델 (Evolutionary: 프로토타이핑, 증분)
  - 애자일 모델 (XP, Scrum)
  - 변환 모델 (Transformation)
  - 나선형 모델 (Spiral)
  - V 모델 (V Model)
  - DevOps 모델

- **프로젝트 특성에 따른 SDLC (Software Development Life Cycle)**
- **소프트웨어 프로세스 표준**: ISO 12207

---

**소프트웨어 개발이란 무엇인가?**

- 최종 목적지에 도달하는 방법은?
- 그곳에 도달하기 위해 무엇이 필요한가?
- 소프트웨어 개발은 어떻게 해야 하는가?

---

**소프트웨어 개발 프로세스**

- 요구사항에서 최종 시스템까지
- 소프트웨어 개발은 지속적이고 절차적인 활동입니다.
- 이러한 활동들은 무엇인가요?
- 소프트웨어 개발을 위한 여러 경로를 어떻게 표현할 수 있나요?

---

## 소프트웨어 프로세스 모델이란

- 소프트웨어 생산 과정
  - 소프트웨어 제품을 구축하고, 제공하고, 배포하고, 진화시키기 위한 과정
  - 아이디어의 시작부터 시스템의 최종 폐기까지
- 생산 과정의 목표
  - 고객의 기대를 충족시키는 것
    - 제시간에 품질 높은 제품을 제공하여
    - 예산 내에서 수익을 창출하며
    - 신뢰성 있고 예측 가능하며 효율적인 생산을 통해

#### 소프트웨어 생명주기 모델 (Software Life Cycle Model)
  - 요구사항 -> 분석 -> 설계 -> 코딩 -> 테스트 -> 제공 -> 운영 및 유지보수 -> 폐기

---

**프로세스 모델이 중요한 이유는?**

- 시장 진출 시간을 단축하고 생산 비용을 절감함
- 프로세스는 제품의 품질에 결정적인 영향을 미침
- 프로세스를 제어함으로써 제품의 품질을 더 잘 제어할 수 있음

**블랙박스 프로세스** (Black-Box Process)
- 내부 진행 상황을 담당자에게만 확인할 수 있음
- 외부에서 진행 상황을 알 수 없으며 피드백이 어려움

**투명한 프로세스** (Transparent Process)
- 계속해서 피드백을 받을 수 있다면, 소프트웨어가 제대로 진행되고 있는지 확인할 수 있음
- 추적표를 통해 요구사항에 맞는 결과물이 만들어졌는지 확인 가능함

---

**소프트웨어 생산 활동**

- **프로세스**: 무엇을 해야 할지에 대한 일련의 (관련된) 단계들
- **주요 활동**:
  - 타당성 검토 (Feasibility Study)
  - 요구사항 도출, 이해, 명세화 (Eliciting, Understanding, and Specifying REQs)
  - 소프트웨어 아키텍처와 상세 설계 (Software Architecture and Detailed Design)
  - 코딩 및 모듈 테스트 (Coding and Module Testing)
  - 통합 및 시스템 테스트 (Integration and System Testing)
  - 제공, 배포 및 유지보수 (Delivery, Deployment, and Maintenance)

타당성 검토 (Feasibility Study)의 세 가지 측면:
1. **경제적 타당성**:
   - 개발한 서비스가 이익을 낼 수 있는가?
2. **기술적 타당성**:
   - 기술적으로 구현 가능한가?
   - 만약 구현이 불가능하다면 외주를 진행할 수 있지만, 회사 내 기술 유출이 우려됨
3. **법률적 타당성**:
   - 사회적으로 문제가 없는가?

---

**소프트웨어 프로세스 모델**

- 소프트웨어 개발 활동을 어떻게 구성할 수 있는지에 대한 표현
- **대표적인 프로세스 모델**:
  - **빌드 앤 픽스 모델** (Build-and-Fix): 코드 작성 후 클라이언트가 만족할 때까지 수정
  - **폭포수 모델** (Waterfall Model): 단계별로 순차 진행
  - **진화적 모델** (Evolutionary Model): 프로토타이핑 및 증분 방식
  - **변환 모델** (Transformation Model): 형식 명세를 바탕으로 한 개발
  - **나선형 모델** (Spiral Model): 위험 분석 중심
  - **기타 모델들**: 다양한 응용 가능한 모델들

---

**빌드 앤 픽스 모델**

- 첫 번째 버전을 작성하고, 클라이언트가 만족할 때까지 수정
- 분석 및 설계를 거치지 않음
- 단일 개발자가 주로 수행하며, 명세가 없이 구축됨
- 큰 제품에는 적합하지 않음
- 오늘날 환경에서는 부적합함:
  - 컴퓨터 배경이 없는 사람들을 위해 개발된 모델
  - 더 엄격한 신뢰성 요구사항
  - 그룹 활동에 적합하지 않음

---

**폭포수 모델**

- 타당성 검토 -> 요구사항 수집 -> 설계 -> 코딩 및 모듈 테스트 -> 통합 및 시스템 테스트 -> 제공, 배포 및 유지보수
- 각 단계의 출력물이 다음 단계의 입력물이 됨
- **기여**:
  - 계획적이고 관리 가능한 접근 방식을 강제함
  - 목표가 잘 이해된 후에 제품을 구현하도록 함

---

**진화적 모델**

- 운영 소프트웨어 제품의 증분을 확장하는 모델
- **개발 전략**:
  1. 사용자에게 무언가를 제공
  2. 사용자에게 추가된 가치를 측정
  3. 관찰된 현실을 기반으로 설계와 목표를 조정

진화적 모델에는 두 가지 유형이 있음:
1. **증분 접근법** (Incremental Approach)
2. **프로토타이핑** (Prototyping)

---

**증분 접근법**

- 첫 번째 빌드를 구현하고 테스트한 후, 후속 빌드를 통합 및 테스트함
- 최종 제품이 완성될 때까지 반복
- **이점**:
  - 사용자가 새로운 제품에 적응할 시간을 제공
  - 변화 수용이 용이해짐
  - 단계적 제공으로 인해 큰 자본이 필요하지 않음

**문제점**:
- 각 통합과 테스트마다 오버헤드가 발생
- 부분적인 시스템이 사용자에 의해 최종 시스템으로 간주될 수 있음

---

**프로토타이핑**

- 첫 번째 버전: 제품의 타당성을 평가하고 요구사항을 확인하는 **버려질 프로토타입**을 제작
- 두 번째 버전: 폭포수 모델을 따름
- **이점**:
  - 비용과 시간을 절감할 수 있음
  - 개발자와 사용자 간의 의사소통을 향상시킴
  - 오류를 조기에 발견할 수 있음
- **문제점**:
  - 변화 예상에 대한 강조가 부족함

---

**신속한 애플리케이션 개발** (Rapid Application Development)

- 소프트웨어 시스템에 대한 **빠른 개발과 제공**이 가장 중요한 요구사항이 됨
- 요구사항이 자주 변화하므로, 소프트웨어가 빠르게 진화해야 함
- 사양, 설계, 구현이 얽혀서 진행되며, 시스템은 여러 버전으로 개발됨

---

**애자일 방법론** (Agile Methods)

- 여러 애자일 방법론:
  - 동적 시스템 개발 방법 (Dynamic System Development Method)
  - 적응형 소프트웨어 개발 (Adaptive Software Development)
  - XP (Extreme Programming)
  - 스크럼 (Scrum)
  - Lean 소프트웨어 개발 등

- 목표는 더 빠르고 신뢰할 수 있는 소프트웨어를 만드는 것

---

**XP 프로세스** (Extreme Programming)

- **역할과 책임**:
  - 프로그래머: 분석, 설계, 테스트, 코딩, 통합
  - 관리자: 프로젝트 프로세스의 진행 관리
  - 고객: 요구사항 및 우선순위 지정

- **XP의 4가지 가치**:
  1. 의사소통 (Communication)
  2. 단순성 (Simplicity)
  3. 피드백 (Feedback)
  4. 용기 (Courage)

---

**XP의 12가지 실천사항**

1. 계획 수립 (Planning Process)
2. 작은 릴리스 (Small Releases)
3. 은유 (Metaphor)
4. 단순한 설계 (Simple Design)
5. 지속적인 테스트 (Continuous Testing)
6. 리팩토링 (Refactoring)
7. 페어 프로그래밍 (Pair Programming)
8. 집단 코드 소유권 (Collective Code Ownership)
9. 지속적 통합 (Continuous Integration)
10. 주 40시간 근무 (40-hour Week)
11. 현장

 고객 (On-site Customer)
12. 코딩 표준 (Coding Standards)

---

**스크럼** (Scrum)

- 반복적 개발을 관리하는 피드백 기반의 경험적 접근 방식
- 세 가지 기둥: **투명성**, **검사**, **적응**
- 스크럼 팀은 자주 개발 중인 제품을 검사하고 팀의 작업 상태를 평가해야 함

---

**변환 모델** (Transformation Model)

- 형식 명세(Z, PetriNet, StateCharts 등)를 기반으로 명세를 점진적으로 구현으로 변환하는 모델
- **문제점**:
  - 전문가 지식이 필요함
  - 산업적 사용에 제한적임

---

**나선형 모델** (Spiral Model)

- 위험 분석에 초점을 맞추고, 고위험 문제를 식별하고 제거하는 데 중점을 둠
- **문제점**:
  - 각 나선에서 위험 분석을 수행하므로 비용이 많이 들 수 있음
  - 대규모 소프트웨어 개발에만 적합함

---

**V 모델**

- 검증 및 확인 (Verification and Validation) 모델로 알려져 있음
- **장점**:
  - 엄격한 절차를 따름
  - 요구사항이 잘 이해된 작은 프로젝트에 적합함
  - 단순하고 이해하기 쉬움
- **단점**:
  - 요구사항이 변동될 가능성이 큰 프로젝트에는 부적합함

---

**CBSE (컴포넌트 기반 소프트웨어 공학) 프로세스**

- 소프트웨어 컴포넌트를 기반으로 한 개발 과정
- **현대 소프트웨어 컴포넌트의 개념**: 소프트웨어 IC
- CBSE 프로세스는 재사용을 통해 설계 및 개발됨

---

**DevOps**

- 개발과 운영을 결합하여 민첩성, 협업, 자동화를 중시하는 철학과 실천 방식
- IT 운영과 개발 간의 **격차를 해소**하고, **더 빠르고 효율적인** 소프트웨어 제공을 목표로 함

---

**프로세스 표준**

- **ISO/IEC/IEEE 12207**: 소프트웨어 생명 주기를 위한 공통 프레임워크를 설정함
  - 소프트웨어 획득, 공급, 개발, 운영 및 유지보수를 관리하고 개선함

---

**레거시 소프트웨어 관리**

- 새로운 소프트웨어를 처음부터 개발할 수 없는 경우가 많음
- 레거시 소프트웨어는 중요한 자산으로 신중히 보존해야 함
- **재공학** (Reengineering): 기존 시스템을 새로운 형태로 변환하는 과정

---

**요약 및 토론**

- **소프트웨어 생산 프로세스 모델**:
  - 폭포수, 진화적 모델(프로토타이핑, 증분), 변환 모델, 나선형 모델, 애자일 모델, DevOps 모델 등
- **프로세스 모델과 방법론의 차이점은 무엇인가?**

---

이번 번역에서는 **모든** 내용을 빠짐없이 반영했습니다. 추가적인 수정이나 문의사항이 있으시면 언제든지 말씀해 주세요!