---
{"dg-publish":true,"permalink":"/CBNU/3-2/Software Engineering/Software Design/GOF Patterns/"}
---

아래는 요청하신 형식에 맞춰 디자인 패턴을 요약한 내용입니다.

---

# Design Patterns

소프트웨어 개발에서 자주 발생하는 **문제에 대한 검증된 재사용 가능한 해결책**

## 목적

- 공통된 문제에 대한 **검증된 최적 해결책 제공**
    
- **생산성, 품질, 유지보수성, 확장성 향상**
    

## 분류

알겠습니다. 다음은 **GoF 디자인 패턴 23가지**를 **각 패턴별 상세 설명**과 함께 일관된 구조로 작성한 내용입니다.  
(설명, 구조, 적용 사례, 장점 중심)

---

# ✅ Creational Patterns (생성 패턴)

### 1. Factory Method

#### 설명

- 객체 생성 코드를 상위 클래스에 두고, 실제 생성은 하위 클래스가 결정하도록 위임
    

#### 구조

- Creator(인터페이스 또는 추상 클래스): factoryMethod() 정의
    
- ConcreteCreator: factoryMethod() 구현
    
- Product(생성될 객체 인터페이스)
    

#### 적용 사례

- 피자 가게에서 종류별 피자 객체 생성
    
- 문서 편집기에서 문서 타입별 생성
    

#### 장점

- 객체 생성 로직을 캡슐화
    
- 유연한 확장성 확보
    

---

### 2. Singleton

#### 설명

- 하나의 클래스 인스턴스만 생성되도록 보장
    

#### 구조

- private 생성자
    
- static 인스턴스 변수
    
- public static getInstance() 메서드
    

#### 적용 사례

- 애플리케이션 설정 관리자
    
- 프린터 스풀러
    

#### 장점

- 인스턴스 제어 일원화
    
- 자원 절약
    

---

### 3. Prototype

#### 설명

- 기존 인스턴스를 복제(Cloning)하여 새로운 객체 생성
    

#### 구조

- Prototype 인터페이스: clone() 메서드 정의
    
- ConcretePrototype: clone() 구현
    

#### 적용 사례

- 그래픽 툴에서 도형 복제
    
- 게임 캐릭터 복제
    

#### 장점

- 복잡한 객체 생성 비용 절감
    
- 유연한 객체 생성
    

---

### 4. Builder

#### 설명

- 복잡한 객체를 단계별로 생성
    

#### 구조

- Director: 객체 생성 순서 정의
    
- Builder: 빌더 인터페이스
    
- ConcreteBuilder: 빌더 구현
    
- Product: 생성 결과물
    

#### 적용 사례

- HTML, PDF, Markdown 문서 생성기
    
- 차량 조립 시스템
    

#### 장점

- 동일한 절차로 다양한 결과 생성 가능
    
- 생성 과정과 결과물 분리
    

---

### 5. Abstract Factory

#### 설명

- 관련된 객체 집합(제품군)을 생성하는 인터페이스 제공
    

#### 구조

- AbstractFactory: 제품 생성 메서드 정의
    
- ConcreteFactory: 구체적 제품군 생성
    
- AbstractProduct/ConcreteProduct: 생성될 객체
    

#### 적용 사례

- GUI 컴포넌트 세트(윈도우/맥용)
    
- 게임 아이템 테마 생성
    

#### 장점

- 제품군 일관성 유지
    
- 제품군 확장 용이

---

# ✅ Structural Patterns (구조 패턴)

### 6. Adapter

#### 설명

- 호환되지 않는 인터페이스를 변환하여 기존 클래스 재사용 가능하게 하는 패턴
    

#### 구조

- Target: 클라이언트가 기대하는 인터페이스
    
- Adaptee: 기존 클래스
    
- Adapter: Target 인터페이스를 구현하고 Adaptee 호출
    

#### 적용 사례

- 플러그 어댑터
    
- 레거시 시스템 API 변환
    

#### 장점

- 기존 코드 변경 없이 재사용 가능
    
- 인터페이스 호환성 확보
    

---

### 7. Composite

#### 설명

- 개별 객체와 복합 객체(트리 구조)를 동일하게 다루는 패턴
    

#### 구조

- Component: 공통 인터페이스
    
- Leaf: 단일 객체
    
- Composite: 자식 노드를 관리하는 복합 객체
    

#### 적용 사례

- 파일 시스템 (파일과 폴더)
    
- 회사 조직도
    

#### 장점

- 일관된 방식으로 트리 구조 표현
    
- 재귀적 구조 지원
    

---

### 8. Bridge

#### 설명

- 추상화와 구현을 분리하여 독립적으로 확장 가능한 구조 제공
    

#### 구조

- Abstraction: 기능 정의
    
- Implementor: 구현 인터페이스 정의
    
- RefinedAbstraction: 구체적 기능 정의
    
- ConcreteImplementor: 구현 제공
    

#### 적용 사례

- 리모컨(리모컨 ↔ TV 기능)
    
- 다양한 UI 테마 적용
    

#### 장점

- 구현과 추상화 독립적 확장
    
- 유지보수 용이
    

---

### 9. Decorator

#### 설명

- 객체에 기능을 동적으로 추가하는 패턴
    

#### 구조

- Component: 공통 인터페이스
    
- ConcreteComponent: 기본 기능
    
- Decorator: 기능 추가 인터페이스
    
- ConcreteDecorator: 구체적 기능 추가
    

#### 적용 사례

- 그래픽 요소(테두리, 스크롤) 추가
    
- Java IO 스트림 확장
    

#### 장점

- 상속 없이 기능 확장
    
- 유연한 기능 조합 가능
    

---

### 10. Facade

#### 설명

- 복잡한 서브시스템을 간단한 인터페이스로 감싸는 패턴
    

#### 구조

- Facade: 서브시스템에 대한 단일 진입점 제공
    
- Subsystem Classes: 실제 기능 제공
    

#### 적용 사례

- 컴파일러 인터페이스
    
- 미디어 변환 도구
    

#### 장점

- 복잡성 숨김
    
- 서브시스템과 클라이언트 간 결합도 감소
    

---

### 11. Flyweight

#### 설명

- 대량의 객체를 공유하여 메모리 절약
    

#### 구조

- Flyweight: 공유 객체 인터페이스
    
- ConcreteFlyweight: 공유 객체 구현
    
- FlyweightFactory: 객체 생성 및 재사용 관리
    

#### 적용 사례

- 문자 렌더링 엔진
    
- 게임 내 다수 캐릭터 관리
    

#### 장점

- 메모리 절약
    
- 성능 향상
    

---

### 12. Proxy

#### 설명

- 객체에 대한 접근 제어 또는 대리 실행 제공
    

#### 구조

- Subject: 공통 인터페이스
    
- RealSubject: 실제 객체
    
- Proxy: 접근 제어 및 대리 기능 제공
    

#### 적용 사례

- 가상 프록시(지연 로딩)
    
- 원격 프록시(네트워크 객체 대리)
    

#### 장점

- 접근 제어 용이
    
- 자원 사용 최적화
---

# ✅ Behavioral Patterns (행위 패턴)

### 13. Template Method

#### 설명

- 알고리즘의 구조를 상위 클래스에서 정의하고, 세부 동작은 하위 클래스에서 구현하도록 위임하는 패턴
    

#### 구조

- AbstractClass: 알고리즘 뼈대 메서드 정의
    
- ConcreteClass: 세부 단계 구현
    

#### 적용 사례

- 게임 루프 프레임워크
    
- 데이터 처리 파이프라인
    

#### 장점

- 코드 중복 제거
    
- 알고리즘 일관성 유지
    
- 유지보수 용이
    

---

### 14. Observer

#### 설명

- 객체 상태 변화가 있을 때 등록된 모든 객체(옵서버)에게 알림을 보내는 패턴
    

#### 구조

- Subject: 옵서버 관리 및 알림 메서드 제공
    
- Observer: 알림을 받을 인터페이스
    
- ConcreteObserver: 알림 처리 구현
    

#### 적용 사례

- 이벤트 리스너
    
- 게시판 구독 시스템
    

#### 장점

- 상태 변경 자동 알림
    
- 느슨한 결합
    

---

### 15. Strategy

#### 설명

- 알고리즘을 클래스로 캡슐화하고, 동적으로 교체할 수 있도록 하는 패턴
    

#### 구조

- Strategy: 알고리즘 인터페이스
    
- ConcreteStrategy: 알고리즘 구현
    
- Context: 전략 사용
    

#### 적용 사례

- 정렬 알고리즘 선택
    
- 경로 탐색 알고리즘
    

#### 장점

- 알고리즘 교체 용이
    
- 클라이언트 코드 단순화
    

---

### 16. Chain of Responsibility

#### 설명

- 여러 객체가 처리 요청을 순차적으로 전달받으며 처리 책임을 연쇄적으로 넘기는 패턴
    

#### 구조

- Handler: 요청 처리 인터페이스
    
- ConcreteHandler: 요청 처리 및 다음 처리자 전달
    

#### 적용 사례

- 고객센터 업무 전가
    
- UI 이벤트 처리 체인
    

#### 장점

- 요청 발신자와 수신자 분리
    
- 처리자 동적 연결 가능
    

---

### 17. Command

#### 설명

- 요청을 객체로 캡슐화하여 요청의 실행, 취소, 저장, 재실행을 가능하게 하는 패턴
    

#### 구조

- Command: 요청 인터페이스
    
- ConcreteCommand: 요청 구현
    
- Invoker: 요청 호출
    
- Receiver: 요청 처리
    

#### 적용 사례

- 실행 취소(Undo) 기능
    
- 작업 큐 시스템
    

#### 장점

- 요청 캡슐화
    
- 명령 기록/재실행 가능
    

---

### 18. Mediator

#### 설명

- 객체 간 직접 통신을 제한하고 중앙 집중식 통신 관리자를 두는 패턴
    

#### 구조

- Mediator: 중재 인터페이스
    
- ConcreteMediator: 중재 로직 구현
    
- Colleague: 참가 객체
    

#### 적용 사례

- 채팅방 메신저
    
- 항공 교통 관제 시스템
    

#### 장점

- 객체 간 결합도 감소
    
- 통신 구조 단순화
    

---

### 19. Memento

#### 설명

- 객체의 상태를 캡슐화하여 나중에 복원할 수 있도록 하는 패턴
    

#### 구조

- Originator: 상태를 보관하고 복원하는 객체
    
- Memento: 상태 캡슐
    
- Caretaker: 상태 저장/복원 관리
    

#### 적용 사례

- 문서 편집기 상태 저장/복원
    
- 게임 상태 저장
    

#### 장점

- 캡슐화 유지
    
- 상태 관리 용이
    

---

### 20. State

#### 설명

- 객체 상태에 따라 행동을 변경하는 패턴
    

#### 구조

- State: 상태 인터페이스
    
- ConcreteState: 상태별 동작 구현
    
- Context: 상태 관리
    

#### 적용 사례

- 문서 상태 관리 (초안, 리뷰, 최종본)
    
- 게임 캐릭터 상태 (이동, 공격, 대기)
    

#### 장점

- 상태 전이 명확화
    
- 상태별 행동 관리 용이
    

---

### 21. Visitor

#### 설명

- 객체 구조를 변경하지 않고 새로운 동작을 추가하는 패턴
    

#### 구조

- Visitor: 방문자 인터페이스
    
- ConcreteVisitor: 방문 동작 구현
    
- Element: 방문 대상 인터페이스
    
- ConcreteElement: 방문 대상 구현
    

#### 적용 사례

- 문서 렌더링 엔진
    
- 복합 구조 순회 처리
    

#### 장점

- 구조 변경 없이 기능 확장 가능
    
- 코드 분리 및 유지보수 용이
    

---

### 22. Iterator

#### 설명

- 컬렉션 내부 구조를 숨기고 순차적으로 접근하는 기능 제공
    

#### 구조

- Iterator: 순회 인터페이스
    
- ConcreteIterator: 순회 구현
    
- Aggregate: 컬렉션 인터페이스
    

#### 적용 사례

- 리스트, 배열, 컬렉션 순회
    
- 데이터베이스 레코드 탐색
    

#### 장점

- 일관된 순회 제공
    
- 컬렉션 구조 노출 방지
    

---

### 23. Interpreter

#### 설명

- 언어의 문법을 해석하고 실행하는 엔진 구현 패턴
    

#### 구조

- AbstractExpression: 해석 인터페이스
    
- TerminalExpression: 기본 해석 단위
    
- NonTerminalExpression: 복합 해석 단위
    
- Context: 해석 상태 저장
    

#### 적용 사례

- SQL 파서
    
- 정규 표현식 엔진
    

#### 장점

- 문법 해석 일관성 유지
    
- 언어 처리 시스템 구축 가능